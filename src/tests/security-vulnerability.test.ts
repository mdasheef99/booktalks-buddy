/**
 * Security Vulnerability Tests
 * 
 * Tests specifically for the critical security vulnerability at Line 58 in membership.ts
 * where users with expired subscriptions retain premium access.
 * 
 * This test file documents the current insecure behavior and validates the fix.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { supabase } from '@/lib/supabase';
import { calculateUserEntitlements } from '@/lib/entitlements/membership';
import { hasEntitlement } from '@/lib/entitlements/permissions';

// Test users with known expired subscriptions
const EXPIRED_USERS = [
  {
    id: 'efdf6150-d861-4f2c-b59c-5d71c115493b',
    username: 'admin',
    currentTier: 'PRIVILEGED',
    subscriptionExpired: '2025-06-30'
  },
  {
    id: '57b3036a-1f67-4144-8f94-c51df437a175',
    username: 'kant',
    currentTier: 'PRIVILEGED',
    subscriptionExpired: '2025-06-16'
  },
  {
    id: 'd5329cc4-d896-4f7e-9f7f-be19a8dfd895',
    username: 'plato',
    currentTier: 'PRIVILEGED_PLUS',
    subscriptionExpired: '2025-06-16'
  },
  {
    id: 'e9f18ee7-f533-422f-b634-8a535d9ddadc',
    username: 'popper',
    currentTier: 'PRIVILEGED_PLUS',
    subscriptionExpired: '2025-06-13'
  },
  {
    id: '0c55465e-7551-48f1-b204-7efcda18c6ab',
    username: 'asdfgh',
    currentTier: 'PRIVILEGED',
    subscriptionExpired: 'never_had_subscription'
  }
];

describe('Security Vulnerability: Line 58 in membership.ts', () => {
  
  describe('Current Insecure Behavior (Before Fix)', () => {
    
    it('should demonstrate the security vulnerability exists', async () => {
      for (const user of EXPIRED_USERS) {
        // Get current database state
        const { data: dbUser } = await supabase
          .from('users')
          .select('membership_tier')
          .eq('id', user.id)
          .single();
        
        // Verify user still has premium tier in database
        expect(dbUser?.membership_tier).toBe(user.currentTier);
        
        // Calculate entitlements using current (insecure) system
        const entitlements = await calculateUserEntitlements(user.id);
        
        // Check if user has premium entitlements
        const premiumEntitlements = [
          'CAN_ACCESS_PREMIUM_CONTENT',
          'CAN_CREATE_UNLIMITED_CLUBS',
          'CAN_ACCESS_EXCLUSIVE_CONTENT',
          'CAN_MODERATE_DISCUSSIONS',
          'CAN_VIEW_ANALYTICS'
        ];
        
        const hasPremiumAccess = premiumEntitlements.some(entitlement => 
          hasEntitlement(entitlements, entitlement)
        );
        
        if (hasPremiumAccess) {
          console.warn(`🔴 SECURITY VULNERABILITY: ${user.username} has premium access despite expired subscription (${user.subscriptionExpired})`);
        }
        
        // This documents the current INSECURE behavior
        // After the fix, this should be false
        expect(hasPremiumAccess).toBe(true);
      }
    });
    
    it('should show the exact line causing the vulnerability', async () => {
      // This test demonstrates the problematic code path
      for (const user of EXPIRED_USERS) {
        const { data: dbUser } = await supabase
          .from('users')
          .select('membership_tier')
          .eq('id', user.id)
          .single();
        
        // This simulates the problematic Line 58: const membershipTier = user?.membership_tier || 'MEMBER';
        const membershipTierFromDatabase = dbUser?.membership_tier || 'MEMBER';
        
        // The vulnerability: this grants premium access based solely on database tier
        // without checking if the subscription is still active
        const isPremiumTier = ['PRIVILEGED', 'PRIVILEGED_PLUS'].includes(membershipTierFromDatabase);
        
        expect(isPremiumTier).toBe(true); // This is the problem!
        
        console.warn(`🔴 Line 58 vulnerability: ${user.username} gets premium tier (${membershipTierFromDatabase}) without subscription validation`);
      }
    });
  });
  
  describe('Subscription Status Verification', () => {
    
    it('should confirm these users have expired or no subscriptions', async () => {
      for (const user of EXPIRED_USERS) {
        const { data: subscriptions } = await supabase
          .from('user_subscriptions')
          .select('is_active, end_date, subscription_type')
          .eq('user_id', user.id)
          .order('end_date', { ascending: false });
        
        if (!subscriptions || subscriptions.length === 0) {
          console.log(`✅ ${user.username}: No subscriptions found`);
          expect(subscriptions?.length || 0).toBe(0);
        } else {
          const latestSubscription = subscriptions[0];
          const isExpired = latestSubscription.end_date && 
            new Date(latestSubscription.end_date) < new Date();
          
          if (isExpired) {
            console.log(`✅ ${user.username}: Subscription expired on ${latestSubscription.end_date}`);
            expect(isExpired).toBe(true);
          }
        }
      }
    });
  });
  
  describe('Impact Assessment', () => {
    
    it('should measure the scope of the security issue', async () => {
      // Count total users with premium tiers but expired subscriptions
      const { data: allPremiumUsers } = await supabase
        .from('users')
        .select('id, username, membership_tier')
        .in('membership_tier', ['PRIVILEGED', 'PRIVILEGED_PLUS']);
      
      let vulnerableUsers = 0;
      
      for (const user of allPremiumUsers || []) {
        const { data: subscription } = await supabase
          .from('user_subscriptions')
          .select('is_active, end_date')
          .eq('user_id', user.id)
          .order('end_date', { ascending: false })
          .limit(1)
          .single();
        
        const hasExpiredSubscription = !subscription || 
          (subscription.end_date && new Date(subscription.end_date) < new Date());
        
        if (hasExpiredSubscription) {
          vulnerableUsers++;
          console.warn(`🔴 Vulnerable user: ${user.username} (${user.membership_tier})`);
        }
      }
      
      console.log(`📊 Security Impact: ${vulnerableUsers} users have premium access without valid subscriptions`);
      expect(vulnerableUsers).toBeGreaterThan(0); // Documents the current problem
    });
  });
  
  describe('Feature Access Tests', () => {
    
    it('should test specific premium features that should be blocked', async () => {
      const premiumFeatures = [
        { entitlement: 'CAN_ACCESS_PREMIUM_CONTENT', description: 'Premium content access' },
        { entitlement: 'CAN_CREATE_UNLIMITED_CLUBS', description: 'Unlimited club creation' },
        { entitlement: 'CAN_ACCESS_EXCLUSIVE_CONTENT', description: 'Exclusive content access' },
        { entitlement: 'CAN_MODERATE_DISCUSSIONS', description: 'Discussion moderation' },
        { entitlement: 'CAN_VIEW_ANALYTICS', description: 'Analytics viewing' }
      ];
      
      for (const user of EXPIRED_USERS) {
        const entitlements = await calculateUserEntitlements(user.id);
        
        console.log(`\n🔍 Testing ${user.username} (${user.currentTier}, expired: ${user.subscriptionExpired}):`);
        
        for (const feature of premiumFeatures) {
          const hasAccess = hasEntitlement(entitlements, feature.entitlement);
          
          if (hasAccess) {
            console.warn(`  🔴 ${feature.description}: GRANTED (should be DENIED)`);
          } else {
            console.log(`  ✅ ${feature.description}: DENIED (correct)`);
          }
          
          // Document current insecure behavior
          // After fix, premium features should be denied for expired users
          if (['CAN_ACCESS_PREMIUM_CONTENT', 'CAN_CREATE_UNLIMITED_CLUBS', 'CAN_ACCESS_EXCLUSIVE_CONTENT'].includes(feature.entitlement)) {
            expect(hasAccess).toBe(true); // This should be false after the fix
          }
        }
      }
    });
  });
});

describe('Post-Fix Security Tests', () => {
  // These tests will validate the fix once implemented
  
  it.skip('should deny premium access after subscription validation fix', async () => {
    for (const user of EXPIRED_USERS) {
      const entitlements = await calculateUserEntitlements(user.id);
      
      const premiumEntitlements = [
        'CAN_ACCESS_PREMIUM_CONTENT',
        'CAN_CREATE_UNLIMITED_CLUBS',
        'CAN_ACCESS_EXCLUSIVE_CONTENT'
      ];
      
      const hasPremiumAccess = premiumEntitlements.some(entitlement => 
        hasEntitlement(entitlements, entitlement)
      );
      
      expect(hasPremiumAccess).toBe(false, 
        `${user.username} should not have premium access after fix`);
    }
  });
  
  it.skip('should maintain basic member access after fix', async () => {
    for (const user of EXPIRED_USERS) {
      const entitlements = await calculateUserEntitlements(user.id);
      
      const basicEntitlements = [
        'CAN_VIEW_PUBLIC_CLUBS',
        'CAN_JOIN_LIMITED_CLUBS',
        'CAN_PARTICIPATE_IN_DISCUSSIONS',
        'CAN_EDIT_OWN_PROFILE'
      ];
      
      const hasBasicAccess = basicEntitlements.every(entitlement => 
        hasEntitlement(entitlements, entitlement)
      );
      
      expect(hasBasicAccess).toBe(true, 
        `${user.username} should maintain basic member access after fix`);
    }
  });
});
